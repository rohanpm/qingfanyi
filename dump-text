#!/usr/bin/env python
# coding=utf-8

import signal
import re
import os
import sys
import pyatspi
from pyatspi import Registry

# NOTE: keybinder MUST be imported after pyatspi to avoid hitting an assert in pyatspi
import keybinder

import gtk
import gtk.gdk

from zhedod.dict import open_dict

DEBUG = 'ZHEDOD_DEBUG' in os.environ and os.environ['ZHEDOD_DEBUG'] == '1'

CJK_TEXT_PATTERN = re.compile(ur'''
     [\u4e00-\u9fff]          # CJK Unified Ideographs
   | [\u3400-\u4dff]          # CJK Unified Ideographs Extension A
   | [\U00020000-\U0002a6df]  # CJK Unified Ideographs Extension B
   | [\uf900-\ufaff]          # CJK Compatibility Ideographs
   | [\U0002f800-\U0002fa1f]  # CJK Compatibility Ideographs Supplement
''', re.VERBOSE)

def debug(msg):
    if DEBUG:
        sys.stdout.flush()
        sys.stderr.write('debug: %s\n' % msg)
        sys.stderr.flush()

def text_contains_cjk(text):
    search = CJK_TEXT_PATTERN.search(text)
    return search is not None

def extract_texts(window):
    out = []

    def collect_chinese(accessible_object, _):
        text_object = get_text_object(accessible_object)
        if not text_object:
            return

        text = text_object.getText(0, -1)
        # NOTE: what if app is not using utf-8?
        text = unicode(text, 'utf-8')
        if not text_contains_cjk(text):
            return

        out.append((text, text_object, accessible_object))

    visit_visible(window, collect_chinese)

    return out


def add_rect(parsed, text_object):
    out = []
    for p in parsed:
        (offset, chars, records) = p
        end = offset + len(chars)
        rect = text_object.getRangeExtents(offset, end, 0)
        out.append((offset, chars, records, rect))
    return out


def process_chinese(window, d):
    targets = extract_texts(window)
    out = []

    for (text, text_object, accessible_object) in targets:
        # parse it
        parsed = d.parse_text(text)
        parsed = add_rect(parsed, text_object)
        out.extend(parsed)
        debug("FOUND TEXT: %s\n%s" % (text, parsed))

    return out


def pixbuf_from_screen(rect):
    # Regarding multi-monitor, my testing indicates that this root window covers _all_
    # the active monitors.
    root = gtk.gdk.get_default_root_window()
    debug("root: %s" % root)
    debug("root extents: %s" % root.get_frame_extents())
    (x, y, w, h) = rect
    pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, w, h)
    pb = pb.get_from_drawable(root, root.get_colormap(), x, y, 0, 0, w, h)
    assert pb
    return pb


def on_shortcut(d):
    window = active_window()
    if not window:
        debug('No active window.  Do nothing.')
        return

    window_c = window.queryComponent()
    active_window_rect = window_c.getExtents(0)
    debug('active window: %s' % active_window_rect)

    (window_x, window_y, width, height) = active_window_rect

    blocks = process_chinese(window, d)

    src_pb = pixbuf_from_screen(active_window_rect)

    copy_pb = []
    for (_, _, _, rect) in blocks:
        (x, y, w, h) = rect
        x -= window_x
        y -= window_y
        rect = (x, y, w, h)
        sub = src_pb.subpixbuf(*rect).copy()
        copy_pb.append((sub, rect))

    mod = src_pb.composite_color_simple(width, height, gtk.gdk.INTERP_NEAREST, 127, 2, 0, 0)

    for (pb, rect) in copy_pb:
        #     def copy_area(src_x, src_y, width, height, dest_pixbuf, dest_x, dest_y)
        (x, y, w, h) = rect
        pb.copy_area(0, 0, w, h, mod, x, y)

    img = gtk.Image()
    img.set_from_pixbuf(mod)
    img.show()

    win = gtk.Window()
    win.add(img)
    win.set_resizable(False)
    win.set_decorated(False)
    win.move(window_x, window_y)
    win.show()

def active_window():
    desktop = pyatspi.Registry.getDesktop(0)
    for app in desktop:
        for window in app:
            if window.getState().contains(pyatspi.STATE_ACTIVE):
                return window


def is_visible(accessible_object):
    """
    Returns true if accessible_object appears to be a visible component on the screen.

    Note that invisible components may still have visible children.
    """
    try:
        c = accessible_object.queryComponent()
        (w, h) = c.getSize()
        # anything smaller than (10,10) is invisible or too small to work with
        return w > 10 and h > 10
    except NotImplementedError:
        return False


def get_text_object(accessible_object):
    try:
        return accessible_object.queryText()
    except NotImplementedError:
        return None


def visit_visible(root, callback, level=0):
    if is_visible(root):
        callback(root, level)

    for child in root:
        visit_visible(child, callback, level + 1)


def main():
    with open_dict() as d:
        keystr = "<Ctrl><Alt>z"
        assert keybinder.bind(keystr, on_shortcut, d)
        signal.signal(signal.SIGINT, Registry.stop)
        signal.signal(signal.SIGTERM, Registry.stop)
        print "Entering loop"
        Registry.start()
        print "Done..."


if __name__ == '__main__':
    main()
